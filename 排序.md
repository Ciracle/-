[TOC]

| 交换排序                 | 冒泡,快速                          |
| ------------------------ | ---------------------------------- |
| 插入排序                 | 直接插入排序,二分插入排序,希尔排序 |
| 选择排序                 | 简单选择排序,堆排序                |
|                          |                                    |
| 基于数字和地址计算的排序 | 计数排序,桶排序,基数排序           |
|                          |                                    |
|                          |                                    |
|                          |                                    |

### 冒泡排序

第一趟排序,对n个记录排序,关键字最大的被安置在第n个位置上

第二趟排序,对n-1个记录排序,关键字次打的被安置在n-1个位置上

时间复杂度		

​	1.最好(正序): 比较次数 n(n-1)/2------n-1+n-2+n-3+....+1;交换次数 0

​	2.最坏(逆序):比较次数 n(n-1)/2;交换次数3/2*(n)(n-1)

​	3.平均时间复杂度 O(n^2) 空间复杂度O(1)

```c
void BubbleSort(int R[],int n)
{
    int i,j,flag;
    int temp;
    for(i=0;i<n-1;i++)
    {
        flag=0;
        for(j=1;j<=i;j++)
            if(R[j-1]>R[j])//前一个比后一个大,要交换
            {
                temp = R[j];
                R[j]=R[j-1];
                R[j-1]=temp;
                flag =1;//本次有发生交换flag置1
            }
        if(flag==0)//本次没发生交换说明有序了,可以结束
        {
            return;
        }
    }
}
```

### 直接插入排序(适合序列基本有序的情况)

​	思想: 整个过程 n-1次,先将序列第一个记录看做有序子序列,从第二个记录开始逐个进行插入,知道有序

时间复杂度:	

​	正序: 比较次数n-1,交换次数0;

​	逆序:比较次数n(n-1)/2,交换次数n(n-1)/2;

#### 二分插入排序

二分查找法确定插入位置 

时间复杂度O(n^2) 空间复杂度O(n)

#### 希尔排序(缩小增量法)[每趟排序都会更有序][不稳定的 \]

取一个正整数 d1<n,把所有相隔d1的记录放一组,组内进行直接插入排序

然后去d2<d1,重复上述操作,直到di=1

时间复杂度过于复杂不考

空间复杂度O(1)

### 选择排序

通过n-1次关键字的比较,从n个记录中找出关键字最小的记录,将他与第一个记录交换;在通过n-2次比较,从剩余n-1个记录中找出最小的记录,与第二个记录交换.......

时间复杂度:	

​	最好:交换0次,最坏:交换n-1次

​	比较次数n-1+n-2+.....+1=n(n-1)/2

### 堆排序算法

1.基本算法

​	将**无序序列**建成一个堆,得到关键字**最小(最大)**的记录,输出堆顶的最小(最大)值,使剩余的n-1个元素重又建成一个堆,则可以得到n个元素的次小值,重复执行,得到一个有序序列.

2.无序序列初始化建成一个堆

​	从无序序列的第n/2个元素(对应完全二叉树的最后一个非叶子结点),到第一个元素为止进行反复筛选

​	时间复杂度:最坏 O(nlogn)

​	空间复杂度:O(n)

### 快速排序

​	思想:非平衡,预处理 二分分治